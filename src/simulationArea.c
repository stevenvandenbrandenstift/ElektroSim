/* simulationArea.c generated by valac 0.22.1, the Vala compiler
 * generated from simulationArea.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * simulationArea.vala
 * Copyright (C) 2014 Steven Vanden Branden <Stevenvandenbrandenstift@gmail.com>
 *
 * ElektroSim is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ElektroSim is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_SIMULATION_AREA (simulation_area_get_type ())
#define SIMULATION_AREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SIMULATION_AREA, SimulationArea))
#define SIMULATION_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SIMULATION_AREA, SimulationAreaClass))
#define IS_SIMULATION_AREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SIMULATION_AREA))
#define IS_SIMULATION_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SIMULATION_AREA))
#define SIMULATION_AREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SIMULATION_AREA, SimulationAreaClass))

typedef struct _SimulationArea SimulationArea;
typedef struct _SimulationAreaClass SimulationAreaClass;
typedef struct _SimulationAreaPrivate SimulationAreaPrivate;

#define TYPE_COMPONENT (component_get_type ())
#define COMPONENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT, Component))
#define COMPONENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT, ComponentClass))
#define IS_COMPONENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT))
#define IS_COMPONENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT))
#define COMPONENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT, ComponentClass))

typedef struct _Component Component;
typedef struct _ComponentClass ComponentClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

#define TYPE_TARGET (target_get_type ())
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))

#define TYPE_NG_SPICE_SIMULATOR (ng_spice_simulator_get_type ())
#define NG_SPICE_SIMULATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NG_SPICE_SIMULATOR, NGSpiceSimulator))
#define NG_SPICE_SIMULATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NG_SPICE_SIMULATOR, NGSpiceSimulatorClass))
#define IS_NG_SPICE_SIMULATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NG_SPICE_SIMULATOR))
#define IS_NG_SPICE_SIMULATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NG_SPICE_SIMULATOR))
#define NG_SPICE_SIMULATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NG_SPICE_SIMULATOR, NGSpiceSimulatorClass))

typedef struct _NGSpiceSimulator NGSpiceSimulator;
typedef struct _NGSpiceSimulatorClass NGSpiceSimulatorClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _SimulationArea {
	GtkDrawingArea parent_instance;
	SimulationAreaPrivate * priv;
};

struct _SimulationAreaClass {
	GtkDrawingAreaClass parent_class;
};

struct _SimulationAreaPrivate {
	GtkListBox* list;
	GList* items;
};

typedef enum  {
	TARGET_INT32
} Target;


static gpointer simulation_area_parent_class = NULL;
static gint simulation_area_netAmount;
static gint simulation_area_netAmount = 0;

GType simulation_area_get_type (void) G_GNUC_CONST;
GType component_get_type (void) G_GNUC_CONST;
#define SIMULATION_AREA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SIMULATION_AREA, SimulationAreaPrivate))
enum  {
	SIMULATION_AREA_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
SimulationArea* simulation_area_new (GtkListBox* list);
SimulationArea* simulation_area_construct (GType object_type, GtkListBox* list);
static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self);
GType target_get_type (void) G_GNUC_CONST;
static gboolean simulation_area_on_drag_drop (SimulationArea* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, guint time);
static gboolean _simulation_area_on_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, guint time_, gpointer self);
static void simulation_area_on_drag_data_received (SimulationArea* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint target_type, guint time);
static void _simulation_area_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint info, guint time_, gpointer self);
static gboolean simulation_area_real_draw (GtkWidget* base, cairo_t* cr);
void component_draw_symbol (Component* self, cairo_t* context);
static void simulation_area_insert_component (SimulationArea* self, gint x, gint y, Component* component);
static Component* simulation_area_get_component (SimulationArea* self, gint index);
Component* component_clone (Component* self, Component* component, gint x, gint y);
gint component_snap (Component* self, GList* list, gint range, gint netAmount);
static void simulation_area_redraw_canvas (SimulationArea* self);
void simulation_area_simulate (SimulationArea* self);
GType ng_spice_simulator_get_type (void) G_GNUC_CONST;
NGSpiceSimulator* ng_spice_simulator_new (void);
NGSpiceSimulator* ng_spice_simulator_construct (GType object_type);
gchar* ng_spice_simulator_generate_file (NGSpiceSimulator* self, GList* components);
void ng_spice_simulator_run_simulation (NGSpiceSimulator* self, GList* components);
static void simulation_area_finalize (GObject* obj);

extern const GtkTargetEntry target_list[1];

static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	gtk_main_quit ();
}


static gboolean _simulation_area_on_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, guint time_, gpointer self) {
	gboolean result;
	result = simulation_area_on_drag_drop (self, _sender, context, x, y, time_);
	return result;
}


static void _simulation_area_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint info, guint time_, gpointer self) {
	simulation_area_on_drag_data_received (self, _sender, context, x, y, selection_data, info, time_);
}


SimulationArea* simulation_area_construct (GType object_type, GtkListBox* list) {
	SimulationArea * self = NULL;
	GtkListBox* _tmp0_ = NULL;
	GtkListBox* _tmp1_ = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SimulationArea*) g_object_new (object_type, NULL);
	_tmp0_ = list;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->list);
	self->priv->list = _tmp1_;
	__g_list_free__g_object_unref0_0 (self->priv->items);
	self->priv->items = NULL;
	simulation_area_netAmount = 1;
	g_signal_connect ((GtkWidget*) self, "destroy", (GCallback) _gtk_main_quit_gtk_widget_destroy, NULL);
	gtk_widget_set_vexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_size_request ((GtkWidget*) self, 500, 500);
	gtk_drag_dest_set ((GtkWidget*) self, GTK_DEST_DEFAULT_MOTION | GTK_DEST_DEFAULT_HIGHLIGHT, target_list, G_N_ELEMENTS (target_list), GDK_ACTION_COPY);
	g_signal_connect_object ((GtkWidget*) self, "drag-drop", (GCallback) _simulation_area_on_drag_drop_gtk_widget_drag_drop, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "drag-data-received", (GCallback) _simulation_area_on_drag_data_received_gtk_widget_drag_data_received, self, 0);
	return self;
}


SimulationArea* simulation_area_new (GtkListBox* list) {
	return simulation_area_construct (TYPE_SIMULATION_AREA, list);
}


static gboolean simulation_area_real_draw (GtkWidget* base, cairo_t* cr) {
	SimulationArea * self;
	gboolean result = FALSE;
	GList* _tmp0_ = NULL;
	cairo_t* _tmp4_ = NULL;
	self = (SimulationArea*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = self->priv->items;
	{
		GList* component_collection = NULL;
		GList* component_it = NULL;
		component_collection = _tmp0_;
		for (component_it = component_collection; component_it != NULL; component_it = component_it->next) {
			Component* _tmp1_ = NULL;
			Component* component = NULL;
			_tmp1_ = _g_object_ref0 ((Component*) component_it->data);
			component = _tmp1_;
			{
				Component* _tmp2_ = NULL;
				cairo_t* _tmp3_ = NULL;
				_tmp2_ = component;
				_tmp3_ = cr;
				component_draw_symbol (_tmp2_, _tmp3_);
				_g_object_unref0 (component);
			}
		}
	}
	_tmp4_ = cr;
	cairo_restore (_tmp4_);
	result = FALSE;
	return result;
}


static gboolean simulation_area_on_drag_drop (SimulationArea* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, guint time) {
	gboolean result = FALSE;
	gboolean is_valid_drop_site = FALSE;
	GdkDragContext* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	is_valid_drop_site = TRUE;
	_tmp0_ = context;
	_tmp1_ = gdk_drag_context_list_targets (_tmp0_);
	if (_tmp1_ != NULL) {
		GdkAtom target_type = 0U;
		GdkDragContext* _tmp2_ = NULL;
		GList* _tmp3_ = NULL;
		gconstpointer _tmp4_ = NULL;
		GtkWidget* _tmp5_ = NULL;
		GdkDragContext* _tmp6_ = NULL;
		GdkAtom _tmp7_ = 0U;
		guint _tmp8_ = 0U;
		_tmp2_ = context;
		_tmp3_ = gdk_drag_context_list_targets (_tmp2_);
		_tmp4_ = g_list_nth_data (_tmp3_, (guint) TARGET_INT32);
		target_type = (GdkAtom) ((GdkAtom) ((guintptr) _tmp4_));
		_tmp5_ = widget;
		_tmp6_ = context;
		_tmp7_ = target_type;
		_tmp8_ = time;
		gtk_drag_get_data (_tmp5_, _tmp6_, _tmp7_, (guint32) _tmp8_);
	} else {
		is_valid_drop_site = FALSE;
		g_print ("SimulationArea: no valid dropsite \n");
	}
	result = is_valid_drop_site;
	return result;
}


/**
 * Emitted when the data has been received from the source. It should check
 * the SelectionData sent by the source, and do something with it. Finally
 * it needs to finish the operation by calling Gtk.drag_finish, which will
 * emit the "data_delete" signal if told to.
 */
static void simulation_area_on_drag_data_received (SimulationArea* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint target_type, guint time) {
	gboolean dnd_success = FALSE;
	gboolean delete_selection_data = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkSelectionData* _tmp1_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp17_ = FALSE;
	GdkDragContext* _tmp18_ = NULL;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_ = FALSE;
	guint _tmp21_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (selection_data != NULL);
	dnd_success = FALSE;
	delete_selection_data = FALSE;
	_tmp1_ = selection_data;
	if (_tmp1_ != NULL) {
		GtkSelectionData* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		_tmp2_ = selection_data;
		_tmp3_ = gtk_selection_data_get_length (_tmp2_);
		_tmp0_ = _tmp3_ >= 0;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		GdkDragContext* _tmp5_ = NULL;
		GdkDragAction _tmp6_ = 0;
		GdkDragContext* _tmp7_ = NULL;
		GdkDragAction _tmp8_ = 0;
		guint _tmp9_ = 0U;
		_tmp5_ = context;
		_tmp6_ = gdk_drag_context_get_suggested_action (_tmp5_);
		if (_tmp6_ == GDK_ACTION_ASK) {
		}
		_tmp7_ = context;
		_tmp8_ = gdk_drag_context_get_suggested_action (_tmp7_);
		if (_tmp8_ == GDK_ACTION_MOVE) {
			delete_selection_data = TRUE;
		}
		_tmp9_ = target_type;
		switch (_tmp9_) {
			case TARGET_INT32:
			{
				gint* data = NULL;
				GtkSelectionData* _tmp10_ = NULL;
				guchar* _tmp11_ = NULL;
				gint _tmp12_ = 0;
				gint _tmp13_ = 0;
				gint* _tmp14_ = NULL;
				Component* _tmp15_ = NULL;
				Component* _tmp16_ = NULL;
				_tmp10_ = selection_data;
				_tmp11_ = gtk_selection_data_get_data (_tmp10_);
				data = (gint*) _tmp11_;
				_tmp12_ = x;
				_tmp13_ = y;
				_tmp14_ = data;
				_tmp15_ = simulation_area_get_component (self, *_tmp14_);
				_tmp16_ = _tmp15_;
				simulation_area_insert_component (self, _tmp12_, _tmp13_, _tmp16_);
				_g_object_unref0 (_tmp16_);
				dnd_success = TRUE;
				break;
			}
			default:
			{
				g_print ("nothing good");
				break;
			}
		}
	}
	_tmp17_ = dnd_success;
	if (_tmp17_ == FALSE) {
		g_print ("DnD data transfer failed!\n");
	}
	_tmp18_ = context;
	_tmp19_ = dnd_success;
	_tmp20_ = delete_selection_data;
	_tmp21_ = time;
	gtk_drag_finish (_tmp18_, _tmp19_, _tmp20_, (guint32) _tmp21_);
}


static Component* simulation_area_get_component (SimulationArea* self, gint index) {
	Component* result = NULL;
	GtkListBox* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GtkListBoxRow* _tmp2_ = NULL;
	Component* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->list;
	_tmp1_ = index;
	_tmp2_ = gtk_list_box_get_row_at_index (_tmp0_, _tmp1_);
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, TYPE_COMPONENT, Component));
	result = _tmp3_;
	return result;
}


static void simulation_area_insert_component (SimulationArea* self, gint x, gint y, Component* component) {
	Component* newComponent = NULL;
	Component* _tmp0_ = NULL;
	Component* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	Component* _tmp4_ = NULL;
	GList* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	Component* _tmp8_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (component != NULL);
	_tmp0_ = component;
	_tmp1_ = component;
	_tmp2_ = x;
	_tmp3_ = y;
	_tmp4_ = component_clone (_tmp0_, _tmp1_, _tmp2_, _tmp3_);
	newComponent = _tmp4_;
	_tmp5_ = self->priv->items;
	_tmp6_ = simulation_area_netAmount;
	_tmp7_ = component_snap (newComponent, _tmp5_, 20, _tmp6_);
	simulation_area_netAmount = _tmp7_;
	_tmp8_ = _g_object_ref0 (newComponent);
	self->priv->items = g_list_append (self->priv->items, _tmp8_);
	simulation_area_redraw_canvas (self);
	_g_object_unref0 (newComponent);
}


static void simulation_area_redraw_canvas (SimulationArea* self) {
	GdkWindow* window = NULL;
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	cairo_region_t* region = NULL;
	GdkWindow* _tmp3_ = NULL;
	cairo_region_t* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	cairo_region_t* _tmp6_ = NULL;
	GdkWindow* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	window = _tmp1_;
	_tmp2_ = window;
	if (NULL == _tmp2_) {
		g_print ("no window");
		_g_object_unref0 (window);
		return;
	}
	_tmp3_ = window;
	_tmp4_ = gdk_window_get_clip_region (_tmp3_);
	region = _tmp4_;
	_tmp5_ = window;
	_tmp6_ = region;
	gdk_window_invalidate_region (_tmp5_, _tmp6_, TRUE);
	_tmp7_ = window;
	gdk_window_process_updates (_tmp7_, TRUE);
	_cairo_region_destroy0 (region);
	_g_object_unref0 (window);
}


void simulation_area_simulate (SimulationArea* self) {
	NGSpiceSimulator* gen = NULL;
	NGSpiceSimulator* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = ng_spice_simulator_new ();
	gen = _tmp0_;
	_tmp1_ = self->priv->items;
	_tmp2_ = ng_spice_simulator_generate_file (gen, _tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp3_);
	_tmp4_ = self->priv->items;
	ng_spice_simulator_run_simulation (gen, _tmp4_);
	_g_object_unref0 (gen);
}


static void simulation_area_class_init (SimulationAreaClass * klass) {
	simulation_area_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SimulationAreaPrivate));
	GTK_WIDGET_CLASS (klass)->draw = simulation_area_real_draw;
	G_OBJECT_CLASS (klass)->finalize = simulation_area_finalize;
}


static void simulation_area_instance_init (SimulationArea * self) {
	self->priv = SIMULATION_AREA_GET_PRIVATE (self);
}


static void simulation_area_finalize (GObject* obj) {
	SimulationArea * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SIMULATION_AREA, SimulationArea);
	_g_object_unref0 (self->priv->list);
	__g_list_free__g_object_unref0_0 (self->priv->items);
	G_OBJECT_CLASS (simulation_area_parent_class)->finalize (obj);
}


GType simulation_area_get_type (void) {
	static volatile gsize simulation_area_type_id__volatile = 0;
	if (g_once_init_enter (&simulation_area_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SimulationAreaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) simulation_area_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SimulationArea), 0, (GInstanceInitFunc) simulation_area_instance_init, NULL };
		GType simulation_area_type_id;
		simulation_area_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "SimulationArea", &g_define_type_info, 0);
		g_once_init_leave (&simulation_area_type_id__volatile, simulation_area_type_id);
	}
	return simulation_area_type_id__volatile;
}



