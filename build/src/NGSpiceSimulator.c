/* NGSpiceSimulator.c generated by valac 0.24.0, the Vala compiler
 * generated from NGSpiceSimulator.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * netlist-generator.vala
 * Copyright (C) 2014 Steven Vanden Branden <StevenVandenbrandenstift@gmail.com>
 *
 * ElektroSim is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ElektroSim is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include </usr/include/ngspice.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>
#include <stdio.h>


#define ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR (elektro_sim_ng_spice_simulator_get_type ())
#define ELEKTRO_SIM_NG_SPICE_SIMULATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR, ElektroSimNGSpiceSimulator))
#define ELEKTRO_SIM_NG_SPICE_SIMULATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR, ElektroSimNGSpiceSimulatorClass))
#define ELEKTRO_SIM_IS_NG_SPICE_SIMULATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR))
#define ELEKTRO_SIM_IS_NG_SPICE_SIMULATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR))
#define ELEKTRO_SIM_NG_SPICE_SIMULATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR, ElektroSimNGSpiceSimulatorClass))

typedef struct _ElektroSimNGSpiceSimulator ElektroSimNGSpiceSimulator;
typedef struct _ElektroSimNGSpiceSimulatorClass ElektroSimNGSpiceSimulatorClass;
typedef struct _ElektroSimNGSpiceSimulatorPrivate ElektroSimNGSpiceSimulatorPrivate;

#define ELEKTRO_SIM_TYPE_COMPONENT (elektro_sim_component_get_type ())
#define ELEKTRO_SIM_COMPONENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ELEKTRO_SIM_TYPE_COMPONENT, ElektroSimComponent))
#define ELEKTRO_SIM_COMPONENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ELEKTRO_SIM_TYPE_COMPONENT, ElektroSimComponentClass))
#define ELEKTRO_SIM_IS_COMPONENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ELEKTRO_SIM_TYPE_COMPONENT))
#define ELEKTRO_SIM_IS_COMPONENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ELEKTRO_SIM_TYPE_COMPONENT))
#define ELEKTRO_SIM_COMPONENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ELEKTRO_SIM_TYPE_COMPONENT, ElektroSimComponentClass))

typedef struct _ElektroSimComponent ElektroSimComponent;
typedef struct _ElektroSimComponentClass ElektroSimComponentClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define ELEKTRO_SIM_TYPE_PARAMETER (elektro_sim_parameter_get_type ())
#define ELEKTRO_SIM_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ELEKTRO_SIM_TYPE_PARAMETER, ElektroSimParameter))
#define ELEKTRO_SIM_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ELEKTRO_SIM_TYPE_PARAMETER, ElektroSimParameterClass))
#define ELEKTRO_SIM_IS_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ELEKTRO_SIM_TYPE_PARAMETER))
#define ELEKTRO_SIM_IS_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ELEKTRO_SIM_TYPE_PARAMETER))
#define ELEKTRO_SIM_PARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ELEKTRO_SIM_TYPE_PARAMETER, ElektroSimParameterClass))

typedef struct _ElektroSimParameter ElektroSimParameter;
typedef struct _ElektroSimParameterClass ElektroSimParameterClass;
typedef struct _ElektroSimComponentPrivate ElektroSimComponentPrivate;

#define ELEKTRO_SIM_TYPE_POINT (elektro_sim_point_get_type ())
#define ELEKTRO_SIM_POINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ELEKTRO_SIM_TYPE_POINT, ElektroSimPoint))
#define ELEKTRO_SIM_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ELEKTRO_SIM_TYPE_POINT, ElektroSimPointClass))
#define ELEKTRO_SIM_IS_POINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ELEKTRO_SIM_TYPE_POINT))
#define ELEKTRO_SIM_IS_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ELEKTRO_SIM_TYPE_POINT))
#define ELEKTRO_SIM_POINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ELEKTRO_SIM_TYPE_POINT, ElektroSimPointClass))

typedef struct _ElektroSimPoint ElektroSimPoint;
typedef struct _ElektroSimPointClass ElektroSimPointClass;

#define ELEKTRO_SIM_COMPONENT_TYPE_COMPONENT_TYPE (elektro_sim_component_component_type_get_type ())

struct _ElektroSimNGSpiceSimulator {
	GObject parent_instance;
	ElektroSimNGSpiceSimulatorPrivate * priv;
	gint identificationLibrary;
	void* userData;
};

struct _ElektroSimNGSpiceSimulatorClass {
	GObjectClass parent_class;
};

struct _ElektroSimComponent {
	GtkListBoxRow parent_instance;
	ElektroSimComponentPrivate * priv;
	GeeArrayList* parameters;
	GeeArrayList* connections;
	cairo_surface_t* image_surface;
	cairo_t* image_context;
	cairo_surface_t* emoticon_surface;
	cairo_t* emoticon_context;
};

struct _ElektroSimComponentClass {
	GtkListBoxRowClass parent_class;
	ElektroSimComponent* (*clone) (ElektroSimComponent* self);
	void (*snap) (ElektroSimComponent* self, gint range, gint x, gint y);
	void (*draw_image) (ElektroSimComponent* self, cairo_t* cr);
	void (*clear_counter) (ElektroSimComponent* self);
	gchar* (*get_netlist_line) (ElektroSimComponent* self);
};

typedef enum  {
	ELEKTRO_SIM_COMPONENT_COMPONENT_TYPE_COMPONENT,
	ELEKTRO_SIM_COMPONENT_COMPONENT_TYPE_TEMPLATE,
	ELEKTRO_SIM_COMPONENT_COMPONENT_TYPE_SIMULATION
} ElektroSimComponentComponentType;


static gpointer elektro_sim_ng_spice_simulator_parent_class = NULL;
extern GeeArrayList* elektro_sim_ng_spice_simulator_items;
GeeArrayList* elektro_sim_ng_spice_simulator_items = NULL;
extern ElektroSimComponent* elektro_sim_ng_spice_simulator_simulation;
ElektroSimComponent* elektro_sim_ng_spice_simulator_simulation = NULL;
static ElektroSimComponent* elektro_sim_ng_spice_simulator_current_component;
static ElektroSimComponent* elektro_sim_ng_spice_simulator_current_component = NULL;
static gchar* elektro_sim_ng_spice_simulator_current_device;
static gchar* elektro_sim_ng_spice_simulator_current_device = NULL;
static gboolean elektro_sim_ng_spice_simulator_ready;
static gboolean elektro_sim_ng_spice_simulator_ready = FALSE;

GType elektro_sim_ng_spice_simulator_get_type (void) G_GNUC_CONST;
enum  {
	ELEKTRO_SIM_NG_SPICE_SIMULATOR_DUMMY_PROPERTY
};
GType elektro_sim_component_get_type (void) G_GNUC_CONST;
ElektroSimNGSpiceSimulator* elektro_sim_ng_spice_simulator_new (void);
ElektroSimNGSpiceSimulator* elektro_sim_ng_spice_simulator_construct (GType object_type);
gint elektro_sim_ng_spice_simulator_receive_output (const gchar* stdout, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_receive_output_send_char (const gchar* sendToCaller, gint id, gconstpointer data);
gint elektro_sim_ng_spice_simulator_receive_simulation_data (const gchar* simulation_status, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_receive_simulation_data_send_stat (const gchar* simulationStatus, gint id, gconstpointer data);
gint elektro_sim_ng_spice_simulator_controlled_exit (gint status, gboolean unload_immediate, gboolean exit_on_quit, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_controlled_exit_controlled_exit (gint status, gboolean unloadImmediate, gboolean exitOnQuit, gint id, gconstpointer data);
gint elektro_sim_ng_spice_simulator_receive_vectors (vecvaluesall* all_vectors, int all_vectors_length1, gint amount, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_receive_vectors_send_data (vecvaluesall* allVectors, gint amount, gint id, gconstpointer data);
gint elektro_sim_ng_spice_simulator_receive_init_vectors (vecinfoall* vecs, int vecs_length1, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_receive_init_vectors_send_init_data (vecinfoall* vecs, gint id, gconstpointer data);
gint elektro_sim_ng_spice_simulator_is_background_thread_running (gboolean running, gint id, gint data);
static gint _elektro_sim_ng_spice_simulator_is_background_thread_running_bg_thread_running (gboolean running, gint id, gconstpointer data);
static gboolean elektro_sim_ng_spice_simulator_check_string (const gchar* line);
static gchar* elektro_sim_ng_spice_simulator_split_line (const gchar* line, gchar** prefix);
static gboolean elektro_sim_ng_spice_simulator_check_device (void);
static gchar* elektro_sim_ng_spice_simulator_strip_std (const gchar* line);
void elektro_sim_component_insert_simulation_data (ElektroSimComponent* self, const gchar* name, const gchar* val, gboolean add);
static void elektro_sim_ng_spice_simulator_print_report (void);
GType elektro_sim_parameter_get_type (void) G_GNUC_CONST;
gpointer elektro_sim_point_ref (gpointer instance);
void elektro_sim_point_unref (gpointer instance);
GParamSpec* elektro_sim_param_spec_point (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void elektro_sim_value_set_point (GValue* value, gpointer v_object);
void elektro_sim_value_take_point (GValue* value, gpointer v_object);
gpointer elektro_sim_value_get_point (const GValue* value);
GType elektro_sim_point_get_type (void) G_GNUC_CONST;
GeeArrayList* elektro_sim_parameter_get_values (ElektroSimParameter* self);
const gchar* elektro_sim_parameter_get_name (ElektroSimParameter* self);
gdouble elektro_sim_parameter_get_val (ElektroSimParameter* self);
ElektroSimParameter* elektro_sim_component_get_parameter (ElektroSimComponent* self, const gchar* name);
void elektro_sim_parameter_set_value (ElektroSimParameter* self, gdouble temp);
void elektro_sim_debug (const gchar* line);
void elektro_sim_ng_spice_simulator_load_netlist (ElektroSimNGSpiceSimulator* self);
gchar* elektro_sim_component_get_netlist_line (ElektroSimComponent* self);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value);
gchar* elektro_sim_ng_spice_simulator_generate_file (ElektroSimNGSpiceSimulator* self, GeeArrayList* comps);
void elektro_sim_ng_spice_simulator_run_simulation (ElektroSimNGSpiceSimulator* self);
GType elektro_sim_component_component_type_get_type (void) G_GNUC_CONST;
static void g_cclosure_user_marshal_OBJECT__ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void elektro_sim_ng_spice_simulator_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gint _elektro_sim_ng_spice_simulator_receive_output_send_char (const gchar* sendToCaller, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_receive_output (sendToCaller, id, (gint) ((gintptr) data));
	return result;
}


static gint _elektro_sim_ng_spice_simulator_receive_simulation_data_send_stat (const gchar* simulationStatus, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_receive_simulation_data (simulationStatus, id, (gint) ((gintptr) data));
	return result;
}


static gint _elektro_sim_ng_spice_simulator_controlled_exit_controlled_exit (gint status, gboolean unloadImmediate, gboolean exitOnQuit, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_controlled_exit (status, unloadImmediate, exitOnQuit, id, (gint) ((gintptr) data));
	return result;
}


static gint _elektro_sim_ng_spice_simulator_receive_vectors_send_data (vecvaluesall* allVectors, gint amount, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_receive_vectors (allVectors, -1, amount, id, (gint) ((gintptr) data));
	return result;
}


static gint _elektro_sim_ng_spice_simulator_receive_init_vectors_send_init_data (vecinfoall* vecs, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_receive_init_vectors (vecs, -1, id, (gint) ((gintptr) data));
	return result;
}


static gint _elektro_sim_ng_spice_simulator_is_background_thread_running_bg_thread_running (gboolean running, gint id, gconstpointer data) {
	gint result;
	result = elektro_sim_ng_spice_simulator_is_background_thread_running (running, id, (gint) ((gintptr) data));
	return result;
}


ElektroSimNGSpiceSimulator* elektro_sim_ng_spice_simulator_construct (GType object_type) {
	ElektroSimNGSpiceSimulator * self = NULL;
	gchar* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	self = (ElektroSimNGSpiceSimulator*) g_object_new (object_type, NULL);
	_g_object_unref0 (elektro_sim_ng_spice_simulator_current_component);
	elektro_sim_ng_spice_simulator_current_component = NULL;
	_tmp0_ = g_strdup ("");
	_g_free0 (elektro_sim_ng_spice_simulator_current_device);
	elektro_sim_ng_spice_simulator_current_device = _tmp0_;
	_tmp1_ = gee_array_list_new (ELEKTRO_SIM_TYPE_COMPONENT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (elektro_sim_ng_spice_simulator_items);
	elektro_sim_ng_spice_simulator_items = _tmp1_;
	ngSpice_Init (_elektro_sim_ng_spice_simulator_receive_output_send_char, _elektro_sim_ng_spice_simulator_receive_simulation_data_send_stat, _elektro_sim_ng_spice_simulator_controlled_exit_controlled_exit, _elektro_sim_ng_spice_simulator_receive_vectors_send_data, _elektro_sim_ng_spice_simulator_receive_init_vectors_send_init_data, _elektro_sim_ng_spice_simulator_is_background_thread_running_bg_thread_running, (gpointer) ((gintptr) 5));
	return self;
}


ElektroSimNGSpiceSimulator* elektro_sim_ng_spice_simulator_new (void) {
	return elektro_sim_ng_spice_simulator_construct (ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static gboolean elektro_sim_ng_spice_simulator_check_string (const gchar* line) {
	gboolean result = FALSE;
	GeeArrayList* wrong = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	gchar* test = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	const gchar* _tmp19_ = NULL;
	gboolean _tmp20_ = FALSE;
	const gchar* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	const gchar* _tmp26_ = NULL;
	gboolean _tmp27_ = FALSE;
	g_return_val_if_fail (line != NULL, FALSE);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (wrong);
	wrong = _tmp0_;
	_tmp1_ = wrong;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, "<<NAN, error = 7>>");
	_tmp2_ = wrong;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, "----------------------------------------------------------------------" \
"----------");
	_tmp3_ = line;
	_tmp4_ = string_strip (_tmp3_);
	_g_free0 (test);
	test = _tmp4_;
	{
		GeeArrayList* _str_list = NULL;
		GeeArrayList* _tmp5_ = NULL;
		GeeArrayList* _tmp6_ = NULL;
		gint _str_size = 0;
		GeeArrayList* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gint _str_index = 0;
		_tmp5_ = wrong;
		_tmp6_ = _g_object_ref0 (_tmp5_);
		_str_list = _tmp6_;
		_tmp7_ = _str_list;
		_tmp8_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp7_);
		_tmp9_ = _tmp8_;
		_str_size = _tmp9_;
		_str_index = -1;
		while (TRUE) {
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			gint _tmp12_ = 0;
			gchar* str = NULL;
			GeeArrayList* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gpointer _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			gboolean _tmp18_ = FALSE;
			_tmp10_ = _str_index;
			_str_index = _tmp10_ + 1;
			_tmp11_ = _str_index;
			_tmp12_ = _str_size;
			if (!(_tmp11_ < _tmp12_)) {
				break;
			}
			_tmp13_ = _str_list;
			_tmp14_ = _str_index;
			_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _tmp13_, _tmp14_);
			str = (gchar*) _tmp15_;
			_tmp16_ = test;
			_tmp17_ = str;
			_tmp18_ = string_contains (_tmp16_, _tmp17_);
			if (_tmp18_) {
				result = FALSE;
				_g_free0 (str);
				_g_object_unref0 (_str_list);
				_g_free0 (test);
				_g_object_unref0 (wrong);
				return result;
			}
			_g_free0 (str);
		}
		_g_object_unref0 (_str_list);
	}
	_tmp19_ = test;
	_tmp20_ = g_str_has_prefix (_tmp19_, "device");
	if (_tmp20_) {
		const gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		_tmp21_ = line;
		_tmp22_ = elektro_sim_ng_spice_simulator_split_line (_tmp21_, NULL);
		_g_free0 (elektro_sim_ng_spice_simulator_current_device);
		elektro_sim_ng_spice_simulator_current_device = _tmp22_;
		result = FALSE;
		_g_free0 (test);
		_g_object_unref0 (wrong);
		return result;
	}
	_tmp23_ = test;
	_tmp24_ = g_str_has_prefix (_tmp23_, "Index");
	if (_tmp24_) {
		gchar* _tmp25_ = NULL;
		_tmp25_ = g_strdup ("Simulation");
		_g_free0 (elektro_sim_ng_spice_simulator_current_device);
		elektro_sim_ng_spice_simulator_current_device = _tmp25_;
		result = FALSE;
		_g_free0 (test);
		_g_object_unref0 (wrong);
		return result;
	}
	_tmp26_ = test;
	_tmp27_ = string_contains (_tmp26_, "hit return for more");
	if (_tmp27_) {
		ngSpice_Command ("c\n");
	}
	result = TRUE;
	_g_free0 (test);
	_g_object_unref0 (wrong);
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gint string_last_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strrchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static gchar* elektro_sim_ng_spice_simulator_split_line (const gchar* line, gchar** prefix) {
	gchar* _vala_prefix = NULL;
	gchar* result = NULL;
	gchar* pros = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gint position2 = 0;
	gint position = 0;
	gint end = 0;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	const gchar* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	const gchar* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	g_return_val_if_fail (line != NULL, NULL);
	_tmp0_ = line;
	_tmp1_ = string_strip (_tmp0_);
	_g_free0 (pros);
	pros = _tmp1_;
	_tmp2_ = pros;
	_tmp3_ = string_replace (_tmp2_, ",", ".");
	_g_free0 (pros);
	pros = _tmp3_;
	_tmp4_ = line;
	_tmp5_ = g_utf8_strlen (_tmp4_, (gssize) (-1));
	end = _tmp5_;
	_tmp6_ = line;
	_tmp7_ = string_last_index_of_char (_tmp6_, (gunichar) ' ', 0);
	position = _tmp7_ + 1;
	_tmp8_ = line;
	_tmp9_ = string_index_of_char (_tmp8_, (gunichar) ' ', 0);
	position2 = _tmp9_;
	_tmp10_ = line;
	_tmp11_ = string_slice (_tmp10_, (glong) 0, (glong) position2);
	_g_free0 (_vala_prefix);
	_vala_prefix = _tmp11_;
	_tmp12_ = line;
	_tmp13_ = string_slice (_tmp12_, (glong) position, (glong) end);
	result = _tmp13_;
	_g_free0 (pros);
	if (prefix) {
		*prefix = _vala_prefix;
	} else {
		_g_free0 (_vala_prefix);
	}
	return result;
}


static gboolean elektro_sim_ng_spice_simulator_check_device (void) {
	gboolean result = FALSE;
	{
		GeeArrayList* _comp_list = NULL;
		GeeArrayList* _tmp0_ = NULL;
		GeeArrayList* _tmp1_ = NULL;
		gint _comp_size = 0;
		GeeArrayList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _comp_index = 0;
		_tmp0_ = elektro_sim_ng_spice_simulator_items;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_comp_list = _tmp1_;
		_tmp2_ = _comp_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_comp_size = _tmp4_;
		_comp_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ElektroSimComponent* comp = NULL;
			GeeArrayList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			ElektroSimComponent* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			_tmp5_ = _comp_index;
			_comp_index = _tmp5_ + 1;
			_tmp6_ = _comp_index;
			_tmp7_ = _comp_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _comp_list;
			_tmp9_ = _comp_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			comp = (ElektroSimComponent*) _tmp10_;
			_tmp11_ = comp;
			_tmp12_ = gtk_widget_get_name ((GtkWidget*) _tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = elektro_sim_ng_spice_simulator_current_device;
			if (g_strcmp0 (_tmp13_, _tmp14_) == 0) {
				ElektroSimComponent* _tmp15_ = NULL;
				ElektroSimComponent* _tmp16_ = NULL;
				_tmp15_ = comp;
				_tmp16_ = _g_object_ref0 (_tmp15_);
				_g_object_unref0 (elektro_sim_ng_spice_simulator_current_component);
				elektro_sim_ng_spice_simulator_current_component = _tmp16_;
				result = TRUE;
				_g_object_unref0 (comp);
				_g_object_unref0 (_comp_list);
				return result;
			}
			_g_object_unref0 (comp);
		}
		_g_object_unref0 (_comp_list);
	}
	result = FALSE;
	return result;
}


static gchar* elektro_sim_ng_spice_simulator_strip_std (const gchar* line) {
	gchar* result = NULL;
	gint end = 0;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint position = 0;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	g_return_val_if_fail (line != NULL, NULL);
	_tmp0_ = line;
	_tmp1_ = g_utf8_strlen (_tmp0_, (gssize) (-1));
	end = _tmp1_;
	_tmp2_ = line;
	_tmp3_ = string_index_of_char (_tmp2_, (gunichar) ' ', 0);
	position = _tmp3_;
	_tmp4_ = line;
	_tmp5_ = string_slice (_tmp4_, (glong) (position + 1), (glong) end);
	result = _tmp5_;
	return result;
}


gint elektro_sim_ng_spice_simulator_receive_output (const gchar* stdout, gint id, gint data) {
	gint result = 0;
	gchar** dataList = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint dataList_length1 = 0;
	gint _dataList_size_ = 0;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	g_return_val_if_fail (stdout != NULL, 0);
	_tmp0_ = stdout;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "\n", 0);
	dataList = _tmp2_;
	dataList_length1 = _vala_array_length (_tmp1_);
	_dataList_size_ = dataList_length1;
	_tmp3_ = dataList;
	_tmp3__length1 = dataList_length1;
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp3_;
		line_collection_length1 = _tmp3__length1;
		for (line_it = 0; line_it < _tmp3__length1; line_it = line_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* line = NULL;
			_tmp4_ = g_strdup (line_collection[line_it]);
			line = _tmp4_;
			{
				const gchar* _tmp5_ = NULL;
				gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				gboolean _tmp8_ = FALSE;
				_tmp5_ = line;
				_tmp6_ = elektro_sim_ng_spice_simulator_strip_std (_tmp5_);
				_g_free0 (line);
				line = _tmp6_;
				_tmp7_ = line;
				_tmp8_ = elektro_sim_ng_spice_simulator_check_string (_tmp7_);
				if (_tmp8_) {
					gboolean _tmp9_ = FALSE;
					_tmp9_ = elektro_sim_ng_spice_simulator_check_device ();
					if (_tmp9_) {
						gchar* val = NULL;
						gchar* parameter = NULL;
						const gchar* _tmp10_ = NULL;
						gchar* _tmp11_ = NULL;
						gchar* _tmp12_ = NULL;
						ElektroSimComponent* _tmp13_ = NULL;
						const gchar* _tmp14_ = NULL;
						const gchar* _tmp15_ = NULL;
						_tmp10_ = line;
						_tmp12_ = elektro_sim_ng_spice_simulator_split_line (_tmp10_, &_tmp11_);
						_g_free0 (parameter);
						parameter = _tmp11_;
						_g_free0 (val);
						val = _tmp12_;
						_tmp13_ = elektro_sim_ng_spice_simulator_current_component;
						_tmp14_ = parameter;
						_tmp15_ = val;
						elektro_sim_component_insert_simulation_data (_tmp13_, _tmp14_, _tmp15_, TRUE);
						_g_free0 (parameter);
						_g_free0 (val);
					}
				}
				_g_free0 (line);
			}
		}
	}
	result = 0;
	dataList = (_vala_array_free (dataList, dataList_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void elektro_sim_ng_spice_simulator_print_report (void) {
	g_print ("==========================================================\n" \
"report:\n");
	{
		GeeArrayList* _component_list = NULL;
		GeeArrayList* _tmp0_ = NULL;
		GeeArrayList* _tmp1_ = NULL;
		gint _component_size = 0;
		GeeArrayList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _component_index = 0;
		_tmp0_ = elektro_sim_ng_spice_simulator_items;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_component_list = _tmp1_;
		_tmp2_ = _component_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_component_size = _tmp4_;
		_component_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ElektroSimComponent* component = NULL;
			GeeArrayList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			ElektroSimComponent* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			_tmp5_ = _component_index;
			_component_index = _tmp5_ + 1;
			_tmp6_ = _component_index;
			_tmp7_ = _component_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _component_list;
			_tmp9_ = _component_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			component = (ElektroSimComponent*) _tmp10_;
			_tmp11_ = component;
			_tmp12_ = gtk_widget_get_name ((GtkWidget*) _tmp11_);
			_tmp13_ = _tmp12_;
			g_print ("\n%s :\n", _tmp13_);
			{
				GeeArrayList* _par_list = NULL;
				ElektroSimComponent* _tmp14_ = NULL;
				GeeArrayList* _tmp15_ = NULL;
				GeeArrayList* _tmp16_ = NULL;
				gint _par_size = 0;
				GeeArrayList* _tmp17_ = NULL;
				gint _tmp18_ = 0;
				gint _tmp19_ = 0;
				gint _par_index = 0;
				_tmp14_ = component;
				_tmp15_ = _tmp14_->parameters;
				_tmp16_ = _g_object_ref0 (_tmp15_);
				_par_list = _tmp16_;
				_tmp17_ = _par_list;
				_tmp18_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp17_);
				_tmp19_ = _tmp18_;
				_par_size = _tmp19_;
				_par_index = -1;
				while (TRUE) {
					gint _tmp20_ = 0;
					gint _tmp21_ = 0;
					gint _tmp22_ = 0;
					ElektroSimParameter* par = NULL;
					GeeArrayList* _tmp23_ = NULL;
					gint _tmp24_ = 0;
					gpointer _tmp25_ = NULL;
					gboolean _tmp26_ = FALSE;
					ElektroSimParameter* _tmp27_ = NULL;
					GeeArrayList* _tmp28_ = NULL;
					GeeArrayList* _tmp29_ = NULL;
					gint _tmp30_ = 0;
					gint _tmp31_ = 0;
					_tmp20_ = _par_index;
					_par_index = _tmp20_ + 1;
					_tmp21_ = _par_index;
					_tmp22_ = _par_size;
					if (!(_tmp21_ < _tmp22_)) {
						break;
					}
					_tmp23_ = _par_list;
					_tmp24_ = _par_index;
					_tmp25_ = gee_abstract_list_get ((GeeAbstractList*) _tmp23_, _tmp24_);
					par = (ElektroSimParameter*) _tmp25_;
					_tmp27_ = par;
					_tmp28_ = elektro_sim_parameter_get_values (_tmp27_);
					_tmp29_ = _tmp28_;
					_tmp30_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp29_);
					_tmp31_ = _tmp30_;
					if (_tmp31_ > 0) {
						gboolean _tmp32_ = FALSE;
						gboolean _tmp33_ = FALSE;
						gboolean _tmp34_ = FALSE;
						ElektroSimParameter* _tmp35_ = NULL;
						const gchar* _tmp36_ = NULL;
						const gchar* _tmp37_ = NULL;
						_tmp35_ = par;
						_tmp36_ = elektro_sim_parameter_get_name (_tmp35_);
						_tmp37_ = _tmp36_;
						if (g_strcmp0 (_tmp37_, "i") == 0) {
							_tmp34_ = TRUE;
						} else {
							ElektroSimParameter* _tmp38_ = NULL;
							const gchar* _tmp39_ = NULL;
							const gchar* _tmp40_ = NULL;
							_tmp38_ = par;
							_tmp39_ = elektro_sim_parameter_get_name (_tmp38_);
							_tmp40_ = _tmp39_;
							_tmp34_ = g_strcmp0 (_tmp40_, "p") == 0;
						}
						if (_tmp34_) {
							_tmp33_ = TRUE;
						} else {
							ElektroSimParameter* _tmp41_ = NULL;
							const gchar* _tmp42_ = NULL;
							const gchar* _tmp43_ = NULL;
							_tmp41_ = par;
							_tmp42_ = elektro_sim_parameter_get_name (_tmp41_);
							_tmp43_ = _tmp42_;
							_tmp33_ = g_strcmp0 (_tmp43_, "activity") == 0;
						}
						if (_tmp33_) {
							_tmp32_ = TRUE;
						} else {
							ElektroSimParameter* _tmp44_ = NULL;
							const gchar* _tmp45_ = NULL;
							const gchar* _tmp46_ = NULL;
							_tmp44_ = par;
							_tmp45_ = elektro_sim_parameter_get_name (_tmp44_);
							_tmp46_ = _tmp45_;
							_tmp32_ = g_strcmp0 (_tmp46_, "work_zone") == 0;
						}
						_tmp26_ = _tmp32_;
					} else {
						_tmp26_ = FALSE;
					}
					if (_tmp26_) {
						ElektroSimParameter* _tmp47_ = NULL;
						const gchar* _tmp48_ = NULL;
						const gchar* _tmp49_ = NULL;
						ElektroSimParameter* _tmp50_ = NULL;
						GeeArrayList* _tmp51_ = NULL;
						GeeArrayList* _tmp52_ = NULL;
						gint _tmp53_ = 0;
						gint _tmp54_ = 0;
						_tmp47_ = par;
						_tmp48_ = elektro_sim_parameter_get_name (_tmp47_);
						_tmp49_ = _tmp48_;
						_tmp50_ = par;
						_tmp51_ = elektro_sim_parameter_get_values (_tmp50_);
						_tmp52_ = _tmp51_;
						_tmp53_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp52_);
						_tmp54_ = _tmp53_;
						g_print ("%s (%i) -> ", _tmp49_, _tmp54_);
						{
							GeeArrayList* _val_list = NULL;
							ElektroSimParameter* _tmp55_ = NULL;
							GeeArrayList* _tmp56_ = NULL;
							GeeArrayList* _tmp57_ = NULL;
							GeeArrayList* _tmp58_ = NULL;
							gint _val_size = 0;
							GeeArrayList* _tmp59_ = NULL;
							gint _tmp60_ = 0;
							gint _tmp61_ = 0;
							gint _val_index = 0;
							_tmp55_ = par;
							_tmp56_ = elektro_sim_parameter_get_values (_tmp55_);
							_tmp57_ = _tmp56_;
							_tmp58_ = _g_object_ref0 (_tmp57_);
							_val_list = _tmp58_;
							_tmp59_ = _val_list;
							_tmp60_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp59_);
							_tmp61_ = _tmp60_;
							_val_size = _tmp61_;
							_val_index = -1;
							while (TRUE) {
								gint _tmp62_ = 0;
								gint _tmp63_ = 0;
								gint _tmp64_ = 0;
								gdouble val = 0.0;
								GeeArrayList* _tmp65_ = NULL;
								gint _tmp66_ = 0;
								gpointer _tmp67_ = NULL;
								gdouble* _tmp68_ = NULL;
								gdouble _tmp69_ = 0.0;
								gdouble _tmp70_ = 0.0;
								_tmp62_ = _val_index;
								_val_index = _tmp62_ + 1;
								_tmp63_ = _val_index;
								_tmp64_ = _val_size;
								if (!(_tmp63_ < _tmp64_)) {
									break;
								}
								_tmp65_ = _val_list;
								_tmp66_ = _val_index;
								_tmp67_ = gee_abstract_list_get ((GeeAbstractList*) _tmp65_, _tmp66_);
								_tmp68_ = (gdouble*) _tmp67_;
								_tmp69_ = *_tmp68_;
								_g_free0 (_tmp68_);
								val = _tmp69_;
								_tmp70_ = val;
								g_print ("%f - ", _tmp70_);
							}
							_g_object_unref0 (_val_list);
						}
						g_print ("\n");
					} else {
						ElektroSimParameter* _tmp71_ = NULL;
						const gchar* _tmp72_ = NULL;
						const gchar* _tmp73_ = NULL;
						ElektroSimParameter* _tmp74_ = NULL;
						gdouble _tmp75_ = 0.0;
						gdouble _tmp76_ = 0.0;
						_tmp71_ = par;
						_tmp72_ = elektro_sim_parameter_get_name (_tmp71_);
						_tmp73_ = _tmp72_;
						_tmp74_ = par;
						_tmp75_ = elektro_sim_parameter_get_val (_tmp74_);
						_tmp76_ = _tmp75_;
						g_print ("%s -> %f :\n", _tmp73_, _tmp76_);
					}
					_g_object_unref0 (par);
				}
				_g_object_unref0 (_par_list);
			}
			_g_object_unref0 (component);
		}
		_g_object_unref0 (_component_list);
	}
}


gint elektro_sim_ng_spice_simulator_receive_simulation_data (const gchar* simulation_status, gint id, gint data) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (simulation_status != NULL, 0);
	_tmp0_ = simulation_status;
	_tmp1_ = string_contains (_tmp0_, "--ready--");
	if (_tmp1_) {
		ElektroSimComponent* _tmp2_ = NULL;
		ElektroSimParameter* _tmp3_ = NULL;
		ElektroSimParameter* _tmp4_ = NULL;
		elektro_sim_ng_spice_simulator_ready = TRUE;
		_tmp2_ = elektro_sim_ng_spice_simulator_simulation;
		_tmp3_ = elektro_sim_component_get_parameter (_tmp2_, "status");
		_tmp4_ = _tmp3_;
		elektro_sim_parameter_set_value (_tmp4_, (gdouble) 1);
		_g_object_unref0 (_tmp4_);
		elektro_sim_debug ("simulation status set to 1");
	}
	result = 0;
	return result;
}


gint elektro_sim_ng_spice_simulator_controlled_exit (gint status, gboolean unload_immediate, gboolean exit_on_quit, gint id, gint data) {
	gint result = 0;
	gint _tmp0_ = 0;
	_tmp0_ = status;
	g_print ("exit status: '%i'\n", _tmp0_);
	result = 0;
	return result;
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


gint elektro_sim_ng_spice_simulator_receive_vectors (vecvaluesall* all_vectors, int all_vectors_length1, gint amount, gint id, gint data) {
	gint result = 0;
	gchar* chars = NULL;
	gchar* _tmp29_ = NULL;
	vector_info info = {0};
	vector_info* _tmp30_ = NULL;
	vector_info _tmp31_ = {0};
	gint _tmp32_ = 0;
	gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	ElektroSimComponent* _tmp37_ = NULL;
	vector_info _tmp38_ = {0};
	vector_info _tmp39_ = {0};
	gint _tmp40_ = 0;
	gdouble _tmp41_ = 0.0;
	gchar* _tmp42_ = NULL;
	gchar* _tmp43_ = NULL;
	ngSpice_Command ("bg_halt");
	{
		GeeArrayList* _component_list = NULL;
		GeeArrayList* _tmp0_ = NULL;
		GeeArrayList* _tmp1_ = NULL;
		gint _component_size = 0;
		GeeArrayList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _component_index = 0;
		_tmp0_ = elektro_sim_ng_spice_simulator_items;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_component_list = _tmp1_;
		_tmp2_ = _component_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_component_size = _tmp4_;
		_component_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ElektroSimComponent* component = NULL;
			GeeArrayList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp12_ = FALSE;
			ElektroSimComponent* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp5_ = _component_index;
			_component_index = _tmp5_ + 1;
			_tmp6_ = _component_index;
			_tmp7_ = _component_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _component_list;
			_tmp9_ = _component_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			component = (ElektroSimComponent*) _tmp10_;
			_tmp13_ = component;
			_tmp14_ = gtk_widget_get_name ((GtkWidget*) _tmp13_);
			_tmp15_ = _tmp14_;
			if (g_strcmp0 (_tmp15_, "Ground") != 0) {
				ElektroSimComponent* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				_tmp16_ = component;
				_tmp17_ = gtk_widget_get_name ((GtkWidget*) _tmp16_);
				_tmp18_ = _tmp17_;
				_tmp12_ = g_strcmp0 (_tmp18_, "Line") != 0;
			} else {
				_tmp12_ = FALSE;
			}
			if (_tmp12_) {
				ElektroSimComponent* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				const gchar* _tmp21_ = NULL;
				_tmp19_ = component;
				_tmp20_ = gtk_widget_get_name ((GtkWidget*) _tmp19_);
				_tmp21_ = _tmp20_;
				_tmp11_ = g_strcmp0 (_tmp21_, "Simulation") != 0;
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				ElektroSimComponent* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				_tmp22_ = component;
				_tmp23_ = gtk_widget_get_name ((GtkWidget*) _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = g_strconcat ("show ", _tmp24_, NULL);
				_tmp26_ = _tmp25_;
				_tmp27_ = g_strconcat (_tmp26_, "\n", NULL);
				_tmp28_ = _tmp27_;
				ngSpice_Command (_tmp28_);
				_g_free0 (_tmp28_);
				_g_free0 (_tmp26_);
			}
			_g_object_unref0 (component);
		}
		_g_object_unref0 (_component_list);
	}
	_tmp29_ = g_strdup ("time");
	chars = _tmp29_;
	_tmp30_ = ngGet_Vec_Info (chars);
	info = *_tmp30_;
	_tmp31_ = info;
	_tmp32_ = _tmp31_.v_length;
	_tmp33_ = g_strdup_printf ("%i", _tmp32_);
	_tmp34_ = _tmp33_;
	_tmp35_ = g_strconcat ("vector time length ", _tmp34_, NULL);
	_tmp36_ = _tmp35_;
	elektro_sim_debug (_tmp36_);
	_g_free0 (_tmp36_);
	_g_free0 (_tmp34_);
	_tmp37_ = elektro_sim_ng_spice_simulator_simulation;
	_tmp38_ = info;
	_tmp39_ = info;
	_tmp40_ = _tmp39_.v_length;
	_tmp41_ = _tmp38_.v_realdata[_tmp40_ - 1];
	_tmp42_ = double_to_string (_tmp41_);
	_tmp43_ = _tmp42_;
	elektro_sim_component_insert_simulation_data (_tmp37_, "time", _tmp43_, TRUE);
	_g_free0 (_tmp43_);
	result = 0;
	_g_free0 (chars);
	return result;
}


gint elektro_sim_ng_spice_simulator_receive_init_vectors (vecinfoall* vecs, int vecs_length1, gint id, gint data) {
	gint result = 0;
	gint _tmp0_ = 0;
	_tmp0_ = id;
	g_print ("init vector received from id: '%i'\n", _tmp0_);
	result = 0;
	return result;
}


gint elektro_sim_ng_spice_simulator_is_background_thread_running (gboolean running, gint id, gint data) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = running;
	if (_tmp0_) {
		g_print ("background thread running\n");
	} else {
		g_print ("background thread NOT running\n");
	}
	result = 0;
	return result;
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


void elektro_sim_ng_spice_simulator_load_netlist (ElektroSimNGSpiceSimulator* self) {
	gchar** netlist = NULL;
	gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint netlist_length1 = 0;
	gint _netlist_size_ = 0;
	gchar** _tmp19_ = NULL;
	gint _tmp19__length1 = 0;
	gchar* _tmp20_ = NULL;
	gchar** _tmp21_ = NULL;
	gint _tmp21__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("netlist by ElektroSim");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	netlist = _tmp1_;
	netlist_length1 = 1;
	_netlist_size_ = netlist_length1;
	{
		GeeArrayList* _component_list = NULL;
		GeeArrayList* _tmp2_ = NULL;
		GeeArrayList* _tmp3_ = NULL;
		gint _component_size = 0;
		GeeArrayList* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		gint _component_index = 0;
		_tmp2_ = elektro_sim_ng_spice_simulator_items;
		_tmp3_ = _g_object_ref0 (_tmp2_);
		_component_list = _tmp3_;
		_tmp4_ = _component_list;
		_tmp5_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_component_size = _tmp6_;
		_component_index = -1;
		while (TRUE) {
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			ElektroSimComponent* component = NULL;
			GeeArrayList* _tmp10_ = NULL;
			gint _tmp11_ = 0;
			gpointer _tmp12_ = NULL;
			gchar** _tmp13_ = NULL;
			gint _tmp13__length1 = 0;
			ElektroSimComponent* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			ElektroSimComponent* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_ = NULL;
			_tmp7_ = _component_index;
			_component_index = _tmp7_ + 1;
			_tmp8_ = _component_index;
			_tmp9_ = _component_size;
			if (!(_tmp8_ < _tmp9_)) {
				break;
			}
			_tmp10_ = _component_list;
			_tmp11_ = _component_index;
			_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _tmp10_, _tmp11_);
			component = (ElektroSimComponent*) _tmp12_;
			_tmp13_ = netlist;
			_tmp13__length1 = netlist_length1;
			_tmp14_ = component;
			_tmp15_ = elektro_sim_component_get_netlist_line (_tmp14_);
			_vala_array_add1 (&netlist, &netlist_length1, &_netlist_size_, _tmp15_);
			_tmp16_ = component;
			_tmp17_ = elektro_sim_component_get_netlist_line (_tmp16_);
			_tmp18_ = _tmp17_;
			g_print ("%s", _tmp18_);
			_g_free0 (_tmp18_);
			_g_object_unref0 (component);
		}
		_g_object_unref0 (_component_list);
	}
	_tmp19_ = netlist;
	_tmp19__length1 = netlist_length1;
	_tmp20_ = g_strdup (".END");
	_vala_array_add2 (&netlist, &netlist_length1, &_netlist_size_, _tmp20_);
	_tmp21_ = netlist;
	_tmp21__length1 = netlist_length1;
	ngSpice_Circ (_tmp21_);
	netlist = (_vala_array_free (netlist, netlist_length1, (GDestroyNotify) g_free), NULL);
}


gchar* elektro_sim_ng_spice_simulator_generate_file (ElektroSimNGSpiceSimulator* self, GeeArrayList* comps) {
	gchar* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	gchar* _tmp34_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (comps != NULL, NULL);
	_tmp0_ = comps;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (elektro_sim_ng_spice_simulator_items);
	elektro_sim_ng_spice_simulator_items = _tmp1_;
	{
		GFile* file = NULL;
		GFile* _tmp2_ = NULL;
		GFile* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		GFileOutputStream* _tmp6_ = NULL;
		GFile* _tmp7_ = NULL;
		GFileOutputStream* _tmp8_ = NULL;
		GDataOutputStream* dos = NULL;
		GDataOutputStream* _tmp9_ = NULL;
		GDataOutputStream* _tmp10_ = NULL;
		GDataOutputStream* _tmp29_ = NULL;
		_tmp2_ = g_file_new_for_path ("./netlist.txt");
		file = _tmp2_;
		_tmp3_ = file;
		_tmp4_ = g_file_query_exists (_tmp3_, NULL);
		if (_tmp4_) {
			GFile* _tmp5_ = NULL;
			_tmp5_ = file;
			g_file_delete (_tmp5_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
		}
		_tmp7_ = file;
		_tmp8_ = g_file_create (_tmp7_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp6_ = _tmp8_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			goto __catch1_g_error;
		}
		_tmp9_ = g_data_output_stream_new ((GOutputStream*) _tmp6_);
		dos = _tmp9_;
		_tmp10_ = dos;
		g_data_output_stream_put_string (_tmp10_, "netlist by ElektroSim2\n", NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dos);
			_g_object_unref0 (_tmp6_);
			_g_object_unref0 (file);
			goto __catch1_g_error;
		}
		{
			GeeArrayList* _component_list = NULL;
			GeeArrayList* _tmp11_ = NULL;
			GeeArrayList* _tmp12_ = NULL;
			gint _component_size = 0;
			GeeArrayList* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gint _tmp15_ = 0;
			gint _component_index = 0;
			_tmp11_ = elektro_sim_ng_spice_simulator_items;
			_tmp12_ = _g_object_ref0 (_tmp11_);
			_component_list = _tmp12_;
			_tmp13_ = _component_list;
			_tmp14_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp13_);
			_tmp15_ = _tmp14_;
			_component_size = _tmp15_;
			_component_index = -1;
			while (TRUE) {
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				gint _tmp18_ = 0;
				ElektroSimComponent* component = NULL;
				GeeArrayList* _tmp19_ = NULL;
				gint _tmp20_ = 0;
				gpointer _tmp21_ = NULL;
				GDataOutputStream* _tmp22_ = NULL;
				ElektroSimComponent* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				ElektroSimComponent* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				_tmp16_ = _component_index;
				_component_index = _tmp16_ + 1;
				_tmp17_ = _component_index;
				_tmp18_ = _component_size;
				if (!(_tmp17_ < _tmp18_)) {
					break;
				}
				_tmp19_ = _component_list;
				_tmp20_ = _component_index;
				_tmp21_ = gee_abstract_list_get ((GeeAbstractList*) _tmp19_, _tmp20_);
				component = (ElektroSimComponent*) _tmp21_;
				_tmp22_ = dos;
				_tmp23_ = component;
				_tmp24_ = elektro_sim_component_get_netlist_line (_tmp23_);
				_tmp25_ = _tmp24_;
				g_data_output_stream_put_string (_tmp22_, _tmp25_, NULL, &_inner_error_);
				_g_free0 (_tmp25_);
				if (_inner_error_ != NULL) {
					_g_object_unref0 (component);
					_g_object_unref0 (_component_list);
					_g_object_unref0 (dos);
					_g_object_unref0 (_tmp6_);
					_g_object_unref0 (file);
					goto __catch1_g_error;
				}
				_tmp26_ = component;
				_tmp27_ = elektro_sim_component_get_netlist_line (_tmp26_);
				_tmp28_ = _tmp27_;
				g_print ("%s", _tmp28_);
				_g_free0 (_tmp28_);
				_g_object_unref0 (component);
			}
			_g_object_unref0 (_component_list);
		}
		_tmp29_ = dos;
		g_data_output_stream_put_string (_tmp29_, ".END", NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dos);
			_g_object_unref0 (_tmp6_);
			_g_object_unref0 (file);
			goto __catch1_g_error;
		}
		_g_object_unref0 (dos);
		_g_object_unref0 (_tmp6_);
		_g_object_unref0 (file);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp30_ = NULL;
		GError* _tmp31_ = NULL;
		const gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp30_ = stdout;
		_tmp31_ = e;
		_tmp32_ = _tmp31_->message;
		fprintf (_tmp30_, "Error: %s\n", _tmp32_);
		_tmp33_ = g_strdup ("ERROR");
		result = _tmp33_;
		_g_error_free0 (e);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	ngSpice_Command ("source ./netlist.txt");
	_tmp34_ = g_strdup ("ok");
	result = _tmp34_;
	return result;
}


void elektro_sim_ng_spice_simulator_run_simulation (ElektroSimNGSpiceSimulator* self) {
	gchar* command = NULL;
	ElektroSimComponent* _tmp12_ = NULL;
	g_return_if_fail (self != NULL);
	command = NULL;
	{
		GeeArrayList* _component_list = NULL;
		GeeArrayList* _tmp0_ = NULL;
		gint _component_size = 0;
		GeeArrayList* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		gint _component_index = 0;
		g_signal_emit_by_name (self, "request-components", ELEKTRO_SIM_COMPONENT_COMPONENT_TYPE_SIMULATION, &_tmp0_);
		_component_list = _tmp0_;
		_tmp1_ = _component_list;
		_tmp2_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_component_size = _tmp3_;
		_component_index = -1;
		while (TRUE) {
			gint _tmp4_ = 0;
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			ElektroSimComponent* component = NULL;
			GeeArrayList* _tmp7_ = NULL;
			gint _tmp8_ = 0;
			gpointer _tmp9_ = NULL;
			ElektroSimComponent* _tmp10_ = NULL;
			ElektroSimComponent* _tmp11_ = NULL;
			_tmp4_ = _component_index;
			_component_index = _tmp4_ + 1;
			_tmp5_ = _component_index;
			_tmp6_ = _component_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _component_list;
			_tmp8_ = _component_index;
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _tmp8_);
			component = (ElektroSimComponent*) _tmp9_;
			_tmp10_ = component;
			_tmp11_ = _g_object_ref0 (_tmp10_);
			_g_object_unref0 (elektro_sim_ng_spice_simulator_simulation);
			elektro_sim_ng_spice_simulator_simulation = _tmp11_;
			_g_object_unref0 (component);
			continue;
		}
		_g_object_unref0 (_component_list);
	}
	_tmp12_ = elektro_sim_ng_spice_simulator_simulation;
	if (_tmp12_ != NULL) {
		ElektroSimComponent* _tmp13_ = NULL;
		ElektroSimParameter* _tmp14_ = NULL;
		ElektroSimParameter* _tmp15_ = NULL;
		GeeArrayList* _tmp16_ = NULL;
		ElektroSimComponent* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_ = NULL;
		ElektroSimComponent* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		_tmp13_ = elektro_sim_ng_spice_simulator_simulation;
		_tmp14_ = elektro_sim_component_get_parameter (_tmp13_, "status");
		_tmp15_ = _tmp14_;
		elektro_sim_parameter_set_value (_tmp15_, (gdouble) 0);
		_g_object_unref0 (_tmp15_);
		g_signal_emit_by_name (self, "request-components", ELEKTRO_SIM_COMPONENT_COMPONENT_TYPE_COMPONENT, &_tmp16_);
		_g_object_unref0 (elektro_sim_ng_spice_simulator_items);
		elektro_sim_ng_spice_simulator_items = _tmp16_;
		elektro_sim_ng_spice_simulator_load_netlist (self);
		elektro_sim_ng_spice_simulator_ready = FALSE;
		g_print ("\n" \
"\n" \
"====================run simulation====================================" \
"==\n" \
"\n");
		_tmp17_ = elektro_sim_ng_spice_simulator_simulation;
		_tmp18_ = elektro_sim_component_get_netlist_line (_tmp17_);
		_g_free0 (command);
		command = _tmp18_;
		_tmp19_ = command;
		_tmp20_ = g_strconcat ("send this: '", _tmp19_, NULL);
		_tmp21_ = _tmp20_;
		_tmp22_ = g_strconcat (_tmp21_, "' from ", NULL);
		_tmp23_ = _tmp22_;
		_tmp24_ = elektro_sim_ng_spice_simulator_simulation;
		_tmp25_ = gtk_widget_get_name ((GtkWidget*) _tmp24_);
		_tmp26_ = _tmp25_;
		_tmp27_ = g_strconcat (_tmp23_, _tmp26_, NULL);
		_tmp28_ = _tmp27_;
		elektro_sim_debug (_tmp28_);
		_g_free0 (_tmp28_);
		_g_free0 (_tmp23_);
		_g_free0 (_tmp21_);
		_tmp29_ = command;
		_tmp30_ = g_strconcat (_tmp29_, "\n", NULL);
		_tmp31_ = _tmp30_;
		ngSpice_Command (_tmp31_);
		_g_free0 (_tmp31_);
	}
	_g_free0 (command);
}


static void g_cclosure_user_marshal_OBJECT__ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gpointer (*GMarshalFunc_OBJECT__ENUM) (gpointer data1, gint arg_1, gpointer data2);
	register GMarshalFunc_OBJECT__ENUM callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gpointer v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_OBJECT__ENUM) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_enum (param_values + 1), data2);
	g_value_take_object (return_value, v_return);
}


static void elektro_sim_ng_spice_simulator_class_init (ElektroSimNGSpiceSimulatorClass * klass) {
	elektro_sim_ng_spice_simulator_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = elektro_sim_ng_spice_simulator_finalize;
	g_signal_new ("request_components", ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_OBJECT__ENUM, GEE_TYPE_ARRAY_LIST, 1, ELEKTRO_SIM_COMPONENT_TYPE_COMPONENT_TYPE);
}


static void elektro_sim_ng_spice_simulator_instance_init (ElektroSimNGSpiceSimulator * self) {
}


static void elektro_sim_ng_spice_simulator_finalize (GObject* obj) {
	ElektroSimNGSpiceSimulator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, ELEKTRO_SIM_TYPE_NG_SPICE_SIMULATOR, ElektroSimNGSpiceSimulator);
	G_OBJECT_CLASS (elektro_sim_ng_spice_simulator_parent_class)->finalize (obj);
}


GType elektro_sim_ng_spice_simulator_get_type (void) {
	static volatile gsize elektro_sim_ng_spice_simulator_type_id__volatile = 0;
	if (g_once_init_enter (&elektro_sim_ng_spice_simulator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ElektroSimNGSpiceSimulatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) elektro_sim_ng_spice_simulator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ElektroSimNGSpiceSimulator), 0, (GInstanceInitFunc) elektro_sim_ng_spice_simulator_instance_init, NULL };
		GType elektro_sim_ng_spice_simulator_type_id;
		elektro_sim_ng_spice_simulator_type_id = g_type_register_static (G_TYPE_OBJECT, "ElektroSimNGSpiceSimulator", &g_define_type_info, 0);
		g_once_init_leave (&elektro_sim_ng_spice_simulator_type_id__volatile, elektro_sim_ng_spice_simulator_type_id);
	}
	return elektro_sim_ng_spice_simulator_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



